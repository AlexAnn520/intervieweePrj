# TCP/IP/HTTP通信协议详解

> 本文档为Android资深高级开发工程师面试准备材料，从基础原理到实战代码，全面掌握网络协议知识。

## 一、网络模型基础

### 1.1 OSI七层模型 vs TCP/IP四层模型

#### OSI七层模型（理论模型）
从上到下：
1. **应用层（Application Layer）**
   - 为应用程序提供网络服务
   - 协议：HTTP、HTTPS、FTP、SMTP、DNS

2. **表示层（Presentation Layer）**
   - 数据格式转换、加密解密、压缩解压
   - 确保不同系统之间数据格式兼容

3. **会话层（Session Layer）**
   - 建立、管理和终止会话连接
   - 控制数据交换的同步

4. **传输层（Transport Layer）**
   - 提供端到端的可靠数据传输
   - 协议：TCP、UDP

5. **网络层（Network Layer）**
   - 路由选择和逻辑寻址
   - 协议：IP、ICMP、ARP

6. **数据链路层（Data Link Layer）**
   - 物理寻址、错误检测、流量控制
   - 设备：交换机

7. **物理层（Physical Layer）**
   - 传输原始比特流
   - 设备：网线、光纤、无线电波

#### TCP/IP四层模型（实际应用）
1. **应用层**：对应OSI的应用层、表示层、会话层
2. **传输层**：对应OSI的传输层
3. **网络层**：对应OSI的网络层
4. **网络接口层**：对应OSI的数据链路层、物理层

### 1.2 数据封装过程

```
应用层数据 → [应用层头部 + 数据] 
         ↓
传输层   → [TCP/UDP头部 + 应用层数据] = 段(Segment)
         ↓
网络层   → [IP头部 + 传输层段] = 包(Packet)
         ↓
链路层   → [以太网头部 + 网络层包 + 以太网尾部] = 帧(Frame)
         ↓
物理层   → 比特流传输
```

## 二、TCP协议详解

### 2.1 TCP协议特点

- **面向连接**：通信前必须先建立连接
- **可靠传输**：确保数据完整、有序到达
- **流量控制**：滑动窗口机制
- **拥塞控制**：慢启动、拥塞避免、快速重传、快速恢复
- **全双工通信**：双方可同时收发数据

### 2.2 TCP报文段结构

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          源端口号（16位）        |      目标端口号（16位）        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        序列号（32位）                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        确认号（32位）                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  数据 |           |U|A|P|R|S|F|                                |
| 偏移  | 保留      |R|C|S|S|Y|I|         窗口大小（16位）        |
| (4位) |  (6位)    |G|K|H|T|N|N|                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          校验和（16位）          |      紧急指针（16位）         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    选项（可变长）                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    数据（可变长）                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**重要标志位说明：**
- **SYN**：同步序列号，建立连接
- **ACK**：确认号有效
- **FIN**：结束连接
- **RST**：重置连接
- **PSH**：接收方应尽快将数据交给应用层
- **URG**：紧急指针有效

### 2.3 TCP三次握手（建立连接）

```
客户端                                          服务器
  |                                              |
  |-------- SYN=1, seq=x ---------------------->| 第一次握手
  |         (SYN_SENT状态)                       | (LISTEN → SYN_RCVD)
  |                                              |
  |<------- SYN=1, ACK=1, seq=y, ack=x+1 -------| 第二次握手
  |         (ESTABLISHED状态)                    |
  |                                              |
  |-------- ACK=1, seq=x+1, ack=y+1 ----------->| 第三次握手
  |                                              | (ESTABLISHED状态)
  |                                              |
  |<============= 数据传输阶段 ================>|
```

**为什么需要三次握手？**
1. **防止失效的连接请求**：避免服务器因收到过期的SYN而建立无效连接
2. **同步双方序列号**：确保双方都知道对方的初始序列号
3. **确认双方收发能力**：
   - 第一次：客户端发送能力正常
   - 第二次：服务器接收、发送能力正常
   - 第三次：客户端接收能力正常

### 2.4 TCP四次挥手（断开连接）

```
客户端                                          服务器
  |                                              |
  |-------- FIN=1, seq=u ---------------------->| 第一次挥手
  |         (FIN_WAIT_1状态)                     | (CLOSE_WAIT状态)
  |                                              |
  |<------- ACK=1, seq=v, ack=u+1 --------------| 第二次挥手
  |         (FIN_WAIT_2状态)                     | 
  |                                              | 服务器可能还有数据要发送
  |<------- FIN=1, ACK=1, seq=w, ack=u+1 -------| 第三次挥手
  |                                              | (LAST_ACK状态)
  |                                              |
  |-------- ACK=1, seq=u+1, ack=w+1 ----------->| 第四次挥手
  |         (TIME_WAIT状态，等待2MSL)            | (CLOSED状态)
  |                                              |
  |         (CLOSED状态)                         |
```

**为什么需要四次挥手？**
- TCP是全双工通信，需要双方都同意断开
- 服务器收到FIN后可能还有数据要发送
- TIME_WAIT状态确保最后的ACK能到达

### 2.5 TCP可靠传输机制

#### 2.5.1 序列号和确认应答
- 每个字节都有序列号
- 接收方通过ACK确认收到的数据

#### 2.5.2 超时重传
- 发送方设置定时器
- 超时未收到ACK则重传

#### 2.5.3 滑动窗口
```
发送窗口：
|---已发送已确认---|---已发送未确认---|---待发送可发送---|---待发送不可发送---|
                  ↑                  ↑                  ↑
              发送窗口左边界      发送窗口右边界      可用窗口右边界
```

#### 2.5.4 流量控制
- 接收方通过窗口大小控制发送方速率
- 防止接收缓冲区溢出

#### 2.5.5 拥塞控制
- **慢启动**：cwnd指数增长
- **拥塞避免**：cwnd线性增长
- **快速重传**：收到3个重复ACK立即重传
- **快速恢复**：调整cwnd避免网络震荡

## 三、HTTP协议详解

### 3.1 HTTP协议特点

- **无连接**：每次请求都需要建立连接（HTTP/1.0）
- **无状态**：不保存客户端状态，需要Cookie/Session
- **简单快速**：请求方法简单，响应快速
- **灵活**：可传输任意类型数据

### 3.2 HTTP请求报文结构

```
请求行：  GET /index.html HTTP/1.1
请求头：  Host: www.example.com
         User-Agent: Mozilla/5.0
         Accept: text/html
         Accept-Language: zh-CN
         Accept-Encoding: gzip, deflate
         Connection: keep-alive
         Cookie: sessionId=abc123
空行：    
请求体：  username=test&password=123456
```

### 3.3 HTTP响应报文结构

```
状态行：  HTTP/1.1 200 OK
响应头：  Date: Mon, 10 Aug 2025 10:00:00 GMT
         Server: Apache/2.4.41
         Content-Type: text/html; charset=UTF-8
         Content-Length: 1234
         Set-Cookie: sessionId=xyz789
         Cache-Control: max-age=3600
空行：    
响应体：  <html><body>Hello World</body></html>
```

### 3.4 HTTP请求方法

| 方法 | 描述 | 幂等性 | 安全性 |
|------|------|--------|--------|
| GET | 获取资源 | 是 | 是 |
| POST | 提交数据 | 否 | 否 |
| PUT | 更新资源（完整） | 是 | 否 |
| DELETE | 删除资源 | 是 | 否 |
| HEAD | 获取响应头 | 是 | 是 |
| OPTIONS | 获取支持的方法 | 是 | 是 |
| PATCH | 更新资源（部分） | 否 | 否 |

### 3.5 HTTP状态码

#### 1xx 信息性状态码
- **100 Continue**：继续请求
- **101 Switching Protocols**：切换协议

#### 2xx 成功状态码
- **200 OK**：请求成功
- **201 Created**：创建成功
- **204 No Content**：无内容返回

#### 3xx 重定向状态码
- **301 Moved Permanently**：永久重定向
- **302 Found**：临时重定向
- **304 Not Modified**：资源未修改

#### 4xx 客户端错误
- **400 Bad Request**：请求错误
- **401 Unauthorized**：未授权
- **403 Forbidden**：禁止访问
- **404 Not Found**：资源不存在

#### 5xx 服务器错误
- **500 Internal Server Error**：服务器内部错误
- **502 Bad Gateway**：网关错误
- **503 Service Unavailable**：服务不可用

### 3.6 HTTP版本演进

#### HTTP/1.0
- 每个请求都需要建立新的TCP连接
- 无法复用连接

#### HTTP/1.1
- **持久连接**：Connection: keep-alive
- **管道化**：可同时发送多个请求
- **分块传输**：Transfer-Encoding: chunked
- **缓存控制**：Cache-Control

#### HTTP/2
- **二进制分帧**：将数据分割为帧
- **多路复用**：一个连接并发处理多个请求
- **头部压缩**：HPACK算法
- **服务器推送**：主动推送资源

#### HTTP/3
- **基于QUIC协议**：UDP替代TCP
- **0-RTT连接**：减少握手延迟
- **改进的拥塞控制**
- **连接迁移**：IP变化不断连接

## 四、HTTPS安全机制

### 4.1 HTTPS = HTTP + SSL/TLS

HTTPS在HTTP基础上增加SSL/TLS层，提供：
- **加密**：防止数据被窃听
- **认证**：确认服务器身份
- **完整性**：防止数据被篡改

### 4.2 SSL/TLS握手过程

```
客户端                                          服务器
  |                                              |
  |-------- Client Hello ---------------------->|
  |  (支持的TLS版本、加密套件、随机数)             |
  |                                              |
  |<------- Server Hello ----------------------|
  |  (选定的TLS版本、加密套件、随机数)             |
  |                                              |
  |<------- Certificate ------------------------|
  |  (服务器证书)                                |
  |                                              |
  |<------- Server Hello Done ------------------|
  |                                              |
  |-------- Client Key Exchange --------------->|
  |  (预主密钥，用服务器公钥加密)                 |
  |                                              |
  |-------- Change Cipher Spec ---------------->|
  |  (切换到加密模式)                            |
  |                                              |
  |-------- Finished -------------------------->|
  |  (握手验证)                                  |
  |                                              |
  |<------- Change Cipher Spec -----------------|
  |<------- Finished ---------------------------|
  |                                              |
  |<========= 加密的应用数据传输 ==============>|
```

### 4.3 数字证书

证书包含：
- 服务器公钥
- 服务器信息
- 证书颁发机构(CA)信息
- 有效期
- 数字签名

**证书验证过程：**
1. 检查证书是否由可信CA签发
2. 验证证书签名
3. 检查证书是否过期
4. 验证证书域名

## 五、Android网络编程实战

### 5.1 基础网络请求实现

详见 `NetworkDemo.java` - 展示HttpURLConnection的基础使用

### 5.2 OkHttp和Retrofit最佳实践

详见 `OkHttpRetrofitDemo.java` - 展示现代Android网络编程推荐方式

## 六、面试要点总结

### 6.1 高频面试题

#### TCP/IP相关

**Q1: 为什么TCP需要三次握手，两次不行吗？**
A: 两次握手无法确保双方都具有收发能力，且无法防止失效的连接请求。三次握手可以：
- 确认双方收发能力正常
- 同步双方序列号
- 防止已失效的连接请求被服务器误认为有效

**Q2: 为什么TCP挥手需要四次？**
A: TCP是全双工通信，双方都可以主动关闭连接。四次挥手确保：
- 双方都同意关闭连接
- 让服务器有机会发送剩余数据
- TIME_WAIT确保最后的ACK能到达

**Q3: TIME_WAIT状态的作用？**
A: 
- 确保最后的ACK能够到达对方
- 让迟来的数据包在网络中消失，防止影响新连接
- 持续时间为2MSL（Maximum Segment Lifetime）

**Q4: TCP如何保证可靠传输？**
A: 
- 序列号和确认应答机制
- 超时重传
- 滑动窗口流量控制
- 拥塞控制（慢启动、拥塞避免、快速重传、快速恢复）
- 校验和

**Q5: TCP和UDP的区别？**
| 特性 | TCP | UDP |
|------|-----|-----|
| 连接性 | 面向连接 | 无连接 |
| 可靠性 | 可靠传输 | 不保证可靠 |
| 有序性 | 保证顺序 | 不保证顺序 |
| 速度 | 较慢 | 快速 |
| 开销 | 开销大（20字节头部） | 开销小（8字节头部） |
| 应用场景 | HTTP、FTP、邮件 | DNS、视频流、游戏 |

#### HTTP相关

**Q6: HTTP和HTTPS的区别？**
A: 
- HTTPS = HTTP + SSL/TLS加密层
- HTTP端口80，HTTPS端口443
- HTTPS需要证书
- HTTPS提供加密、认证、完整性保护

**Q7: HTTP/1.0、1.1、2.0的主要区别？**
A: 
- **HTTP/1.0**：短连接，每个请求都要建立新连接
- **HTTP/1.1**：持久连接、管道化、分块传输、Host头部
- **HTTP/2.0**：二进制分帧、多路复用、头部压缩、服务器推送

**Q8: GET和POST的区别？**
A: 
- 语义：GET获取资源，POST提交数据
- 参数位置：GET在URL，POST在请求体
- 长度限制：GET有限制（约2KB），POST理论无限制
- 安全性：GET参数暴露在URL，POST相对安全
- 幂等性：GET幂等，POST非幂等
- 缓存：GET可缓存，POST不缓存

**Q9: Cookie和Session的区别？**
A: 
- 存储位置：Cookie在客户端，Session在服务器
- 安全性：Session更安全
- 大小限制：Cookie约4KB，Session无限制
- 生命周期：Cookie可设置过期时间，Session依赖于服务器设置

**Q10: 什么是跨域？如何解决？**
A: 跨域是浏览器同源策略的限制。解决方案：
- CORS（跨域资源共享）
- JSONP（仅支持GET）
- 代理服务器
- WebSocket

### 6.2 Android网络编程要点

**Q11: Android中网络请求为什么不能在主线程？**
A: 
- Android 3.0后，在主线程执行网络请求会抛出NetworkOnMainThreadException
- 网络请求耗时，会导致ANR（Application Not Responding）
- 影响UI响应，造成界面卡顿

**Q12: OkHttp的优势？**
A: 
- 连接池复用，减少延迟
- GZIP压缩，减少数据传输
- 响应缓存，避免重复请求
- 自动重试和重定向
- 支持HTTP/2和WebSocket
- 拦截器机制，方便扩展

**Q13: Retrofit的优势？**
A: 
- 接口化API定义，代码清晰
- 自动序列化/反序列化
- 支持多种数据格式转换
- 注解式配置，简洁明了
- 支持RxJava，方便异步处理
- 基于OkHttp，性能优秀

**Q14: 如何处理网络请求的异常？**
A: 
- 超时异常：设置合理的超时时间
- 连接异常：检查网络状态，提供重试机制
- 解析异常：try-catch处理，提供默认值
- 服务器异常：根据错误码处理，如401刷新Token
- 使用统一的错误处理机制

**Q15: 如何优化网络请求？**
A: 
- 使用连接池复用连接
- 开启GZIP压缩
- 合理使用缓存策略
- 批量请求，减少请求次数
- 使用CDN加速
- 图片懒加载和分页加载
- 使用WebP等高效图片格式
- DNS优化和预连接

### 6.3 安全相关

**Q16: 如何防止中间人攻击？**
A: 
- 使用HTTPS
- 证书固定（Certificate Pinning）
- 公钥固定（Public Key Pinning）
- 双向认证
- 避免信任所有证书

**Q17: 如何保护API接口安全？**
A: 
- 使用HTTPS传输
- API签名验证
- Token认证机制
- 请求频率限制
- 参数加密
- 时间戳防重放攻击

### 6.4 性能优化

**Q18: 如何监控网络请求性能？**
A: 
- 使用OkHttp的EventListener
- 添加日志拦截器
- 使用Charles、Fiddler等抓包工具
- 集成APM（应用性能监控）工具
- 自定义性能统计

**Q19: 如何实现断点续传？**
A: 
- 使用HTTP Range头部
- 记录已下载的字节数
- 服务器返回206状态码
- 合并文件片段
- 校验文件完整性

**Q20: WebSocket和HTTP的区别？**
A: 
- WebSocket是全双工通信，HTTP是半双工
- WebSocket是持久连接，HTTP是短连接（1.0）
- WebSocket适合实时通信，HTTP适合请求响应
- WebSocket协议标识ws://或wss://
- WebSocket建立在HTTP基础上，通过Upgrade升级

### 6.5 实战经验

**最佳实践建议：**
1. **错误处理**：建立统一的错误处理机制
2. **超时设置**：根据业务场景设置合理超时
3. **重试策略**：实现智能重试，避免雪崩
4. **缓存策略**：合理使用缓存，提升用户体验
5. **安全防护**：不信任客户端数据，做好参数校验
6. **性能监控**：建立完善的监控体系
7. **日志记录**：记录关键信息，便于问题排查
8. **版本控制**：API版本管理，保证兼容性

## 总结

本文档从网络模型基础开始，深入讲解了TCP/IP协议栈的核心知识，包括TCP的三次握手、四次挥手、可靠传输机制，HTTP协议的演进和特性，以及HTTPS的安全机制。在实战部分，提供了Android原生网络编程和现代网络框架（OkHttp、Retrofit）的详细示例代码。最后总结了面试中的高频问题和最佳实践，帮助Android开发者全面掌握网络编程知识。

掌握这些知识点，不仅能应对面试，更能在实际开发中设计出高效、安全、可靠的网络通信方案。
